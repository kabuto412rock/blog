<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 程式開發者的冒險</title>
    <link>https://kabuto412rock.github.io/posts/</link>
    <description>Recent content in Posts on 程式開發者的冒險</description>
    <image>
      <url>https://kabuto412rock.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://kabuto412rock.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 09 Oct 2023 07:24:04 +0000</lastBuildDate><atom:link href="https://kabuto412rock.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Day30 使用Cloudflare部屬Vue靜態網站</title>
      <link>https://kabuto412rock.github.io/posts/it-day30/</link>
      <pubDate>Mon, 09 Oct 2023 07:24:04 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day30/</guid>
      <description>目前撲克牌遊戲網站都是在自己的電腦用npm run dev啟動，今天會介紹如何部屬Vue專案到CloudFlare提供對外連線的網站，操作有誤的地方再請多多指教。
使用Github Aciton建立 以下的操作需要事先註冊Cloudflare的帳號 和GitHub的帳號
第0步 建立CloudFlare Page的Project 我是參考這個YouTube影片學習如何建立Cloudflare Page專案， 但跟影片不同的部分我在1:56我是選only-select-repositories選擇單一Repo的權限並命名專案名稱ithelp-game-test。
影片看到5分鐘的時候，Cloudflare網站本身停止回應，後面的步驟就沒跟著影片教學做，後面第1~3步驟是我一步步看文件試出來的並非完全照官方建議走，因為需按專案本身調整。 第1步 建立 Cloudflare API Token 參考Cloudflare Pages GitHub Action說明以下只是我再額外自己截圖實作的步驟。
登入帳號來到Cloudflare的儀表板，先點選左下角的Workers &amp;amp; Pages 接著點擊右手邊連結Manage API tokens進入管理API Token的頁面 點擊藍色按鈕Create Token前往建立API Token的頁面 來到API Tokens頁面後點選Create Custom Token旁的藍色按鈕Get Started 填寫Token name這邊幫Token取名為Deploy with github 在Permisions區塊點選Add新增一個權限Account/Cloudflare/Edit ，接著畫面拉到最下方點擊藍色按鈕Continue to summary。 此時Cloudflare會讓你再次確認權限，只需要注意畫面上有出現All accounts - Cloudflare Pages:Edit這個，沒問題就繼續點擊藍色按鈕Create Token。 至此Cloudflare API Token建立成功，點擊按鈕Copy先複製起來 第2步 將Cloudflare API Token設置於Github Repo 此處Github儲存庫是kabuto412rock/ithelp-pokergame
前往Github的儲存庫點擊Setting-&amp;gt;Secrets and Variables-&amp;gt;Actions 來到Actions secrets and variables頁面後點擊綠色按鈕New Repository secret 設置新的密鑰CLOUDFLARE_API_TOKEN 填入先前取得的Cloudflare API Token 設置新的密鑰CLOUDFLARE_ACCOUNT_ID填入在Cloudflare的儀表板右手邊Manage API tokens上方的Account ID 在分支main加入檔案.</description>
    </item>
    
    <item>
      <title>Day29 簡單評估是否還有活路</title>
      <link>https://kabuto412rock.github.io/posts/it-day29/</link>
      <pubDate>Sun, 08 Oct 2023 00:23:02 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day29/</guid>
      <description>目前所製作的經典紙牌接龍其實是源自於Klondike Solitaire的規則，只是發牌區是一次抽一張的循環制，因為網路上有看到每次都是抽3張但只能移動最上面那一張的規則，那種非常難玩挑戰性也很大。
判斷紙牌接龍無解這個問題這兩天困擾我很久，在查過無數資料略讀幾篇論文後，尤其實際有用的資料大多是英文論文😭，發現這絕對不是一兩天的空餘時間就可以理解的目標，所以決定降低目標不去判斷是否已經死局，改為【簡單評估是否還有活路】。
簡單評估是否還有活路 尋找活路的最容易想到的3種可能移動方式:
七牌堆最後一張後面要接的牌存在於發牌區中 任一七牌堆壓在隱藏牌上放的那張可以接在其他七牌堆的後面 發牌區任一張牌或七牌堆的最後一張 可移動結算牌堆 開始實作 按照簡單評估的三項規則依序檢查，若有檢查可移動的方式為true就不會繼續檢查後續的規則，以下為程式碼:
// poker-helper.js /** 檢查是否還有效的移動卡牌 * @param {CardStacks} cardStacks * @returns {boolean} 有有效移動為true 可能沒有為false */ function checkValidMove(cardStacks) { const dealerStacksValues = cardStacks[&amp;#39;dealerStacks&amp;#39;].map((card) =&amp;gt; card.value); const seventLastValues = {}; // 1. `七牌堆`最後一張後面要接的牌存在於`發牌區`中 let haveMove1 = SEVEN_STACKS.some((name) =&amp;gt; { const stack = cardStacks[name]; if (stack.length === 0) { return false; } const lastCard = stack[stack.length - 1]; const lastCardNumber = lastCard.value % 13; seventLastValues[name] = lastCard.</description>
    </item>
    
    <item>
      <title>Day28 評估是否無牌可走，建議棄權的提示(嘗試失敗)</title>
      <link>https://kabuto412rock.github.io/posts/it-day28/</link>
      <pubDate>Sat, 07 Oct 2023 07:34:01 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day28/</guid>
      <description>前言 因為在玩紙牌接龍的過程中可能會被玩到進入無解的情況，也就是再怎麼移動撲克牌都無法完成，所以如何在遊玩中告知玩家這件事情蠻重要的，避免不必要的嘗試。
思考如何實現 老實說這篇文章可能是對我來說最難寫的，雖然身為開發者可以知道7牌堆全部的蓋牌底下是什麼花色數字， 但如何知道場上已經無解又是一回事。
基本上不考慮暴力的窮舉法，其實查到的結果大致可以推導無解的情況，不論是先天或是後天操作導致的無解都是因為疊在蓋牌上方的牌無法移動導致蓋牌無法打開，所以昨天自動結算才可以依照已經沒有蓋牌的情況下當作全部完成。
所以理論上7牌堆如果出現壓住隱藏牌的那一張未來完全無法移動，那就代表死局。
決定判斷死局的演算法(有誤) 雖然看了很多篇文章也理解死局的構成就是壓在蓋牌上的牌無法移動， 但沒有相對簡單的判斷的方法&amp;hellip;
在邊玩接龍邊思考死局判斷的過程中，想到一個判斷方法在此命名為異色大一若隱即死局。
名稱聽起來很中二，檢查方式是7牌堆共7行，每一直行最上面壓住隱牌的第一張牌視為檢查點(Ex: 梅花6)， 檢查隱藏牌中是否有兩個花色與檢查點不同且大一號的數字(Ex: 紅心7、方塊7)，若有則視為此局已無解(死局)，若無則繼續檢查其他的檢查點。
範例圖: 黑色框為隱藏牌、紫色為檢查點、橘色為相對檢查點大一號的異色牌 小結 實作後發現此演算法有錯誤會出現判斷活局/死局相反的情況，
但還是把程式碼推上去，明天繼續研究是否有其他方法解🫡。
程式碼: https://github.com/kabuto412rock/ithelp-pokergame/tree/day28
參考文件
知乎-深度剖析微软《纸牌》玩法 Quora-Does the solitaire game always have a solution? </description>
    </item>
    
    <item>
      <title>Day27 當牌全開時自動結算</title>
      <link>https://kabuto412rock.github.io/posts/it-day27/</link>
      <pubDate>Fri, 06 Oct 2023 05:25:00 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day27/</guid>
      <description>前言 如標題所言，今天要做的就是補上『當牌全開時視為已完成遊戲』自動結算遊戲時間、分數， 有實際在現實世界中用撲克牌玩過接龍的應該知道其實最麻煩的就是收牌結尾，因為最後只是慢慢把所有牌都移到結算牌堆。
事先說明: 此篇不會實作自動移牌的動畫效果。
開發前思考 判斷牌全開不難! 不需要判斷全部牌是否已打開， 只需要判斷7牌堆每堆最上面第一張牌是否已打開，若有蓋著那就不能結算， 若每堆第一張都沒蓋著就可以開始結算。
結算分數時只需要考慮補上發牌區、移牌區有幾張牌，再用加分的方式計算最後的總分。
實作過程 修改遊戲結算時機 原本函數checkSolitaireGameDone(cardStacks)是判斷結算牌堆集滿13張牌則當作遊戲結束，但思考過後結算牌堆都集滿13張等同於七牌區的牌全空一樣會回應true，因此放心調整為檢查七牌堆的最上方開牌的狀態當作遊戲結束的依據。
// poker-helper.js /** * 檢查紙牌接龍是否完成 * @param {CardStacks} cardStacks */ function checkSolitaireGameDone(cardStacks) { // 檢查每組牌堆第一張牌覆蓋著，就代表遊戲還沒結束 const isDone = SEVEN_STACKS.reduce((prev, stackName) =&amp;gt; { const stack = cardStacks[stackName]; if (stack.length &amp;gt; 0 &amp;amp;&amp;amp; (!stack[0].isOpen)) { return false; } return prev; }, true); return isDone; } 計算剩餘牌數&amp;amp;結算分數 新增函數getRemainCardCount(cardStacks)計算並返回發牌區和七牌堆的剩餘牌數
// poker-helper.js /** * 計算剩餘在發牌區和7牌堆的張數 * @param {CardStacks} cardStacks * @returns {Object} {dealer: number, seven: number} */ function getRemainCardCount(cardStacks) { let dealerStacksCount = cardStacks[&amp;#39;dealerStacks&amp;#39;].</description>
    </item>
    
    <item>
      <title>Day26 實作功能【返回上一步】</title>
      <link>https://kabuto412rock.github.io/posts/it-day26/</link>
      <pubDate>Thu, 05 Oct 2023 02:04:38 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day26/</guid>
      <description>前言 因為玩接龍有時會有按錯步，這時候沒有返回上一步的機制就只能硬著頭皮玩下去或按重置，今天想解決這個問題。
開發前的思考 在ReactJS官方學習文件中OOXX遊戲Tic-Tac-Toe也有提到時光旅行的實作，基本上就是每一步更動後的結果狀態都推入(Push)陣列變數history裡面，時光回朔就是將結果狀態直接設為history[index]。
目前開發下來的程式碼大概要回到上一步的只有分數、牌組、發牌的索引， 經過的時間應該就不用上一步。
實作過程 儲存遊戲變化的歷史 首先宣告一個負責儲存歷史的ref變數history
const history = ref([]); 宣告函數pushStateToHistory()負責撰寫把最新的狀態推入history
累積超過30個後會將最舊的狀態移除再推入最新的狀態，避免暫存太多的上一步驟。 因為reactive的關係所以不得不手動深度複製每張卡牌，這也是為什麼要做elemFunc的原因 /** 儲存當前狀態到歷史紀錄 */ function pushStateToHistory() { if (history.value.length &amp;gt; 30) { const startIndex = history.value.length - 30; history.value = history.value.slice(startIndex, history.value.length); } const elemFunc = (card) =&amp;gt; ({ &amp;#34;value&amp;#34;: card.value, &amp;#34;isOpen&amp;#34;: card.isOpen, &amp;#34;isDone&amp;#34;: card.isDone, }); history.value = [ ...history.value, { &amp;#34;cardStacks&amp;#34;: { first: cardStacks.first.slice().map(elemFunc), second: cardStacks.second.slice().map(elemFunc), third: cardStacks.third.slice().map(elemFunc), fourth: cardStacks.fourth.slice().map(elemFunc), fifth: cardStacks.fifth.slice().map(elemFunc), sixth: cardStacks.sixth.slice().map(elemFunc), seventh: cardStacks.</description>
    </item>
    
    <item>
      <title>Day25 紙牌接龍-結算畫面採用Modal和修正移牌優先權</title>
      <link>https://kabuto412rock.github.io/posts/it-day25/</link>
      <pubDate>Wed, 04 Oct 2023 03:05:48 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day25/</guid>
      <description>前言 今天會調整結算畫面的顯示、修正連點移牌的優先權錯誤(應該最優先移入結算牌堆而非七牌堆)。
結算畫面調整 安裝套件 bootstrap-vue-next 昨日完成的結算畫面是跳出來的瀏覽器訊息，畫面完全看各家的瀏覽器制式化只能點確認，即使擋住原本的遊戲畫面是我想要的效果，但更想要的是可客製化頁面的互動視窗Modal。
雖然可以自己土炮撰寫Modal但看帳號名字就知道我很懶，我打算撿現成的套件看能不能快速客製化介面&amp;hellip;然後就找到bootstrap-vue-next這個套件，聽名字就知道是針對Vue3特別拉出來的實現。
先照著官方文件安裝依賴:
npm i bootstrap bootstrap-vue-next npm i unplugin-vue-components -D 這個 unplugin-vue-components 主要是方便自動載入有副作用(side effect)的功能到你的元件中，詳細可參考官方說明，畢竟Bootstrap有副作用才方便?!
接著調整vite.config.js的內容，主要是在plugins屬性對應的陣列中添加Components 包裹 BootstrapVueNextResolver的依賴:
// vite.config.js import { fileURLToPath, URL } from &amp;#39;node:url&amp;#39; import { defineConfig } from &amp;#39;vite&amp;#39; import vue from &amp;#39;@vitejs/plugin-vue&amp;#39; import Components from &amp;#39;unplugin-vue-components/vite&amp;#39; import {BootstrapVueNextResolver} from &amp;#39;unplugin-vue-components/resolvers&amp;#39; // https://vitejs.dev/config/ export default defineConfig({ plugins: [ vue(), Components({ resolvers: [BootstrapVueNextResolver()], }), ], resolve: { alias: { &amp;#39;@&amp;#39;: fileURLToPath(new URL(&amp;#39;./src&amp;#39;, import.</description>
    </item>
    
    <item>
      <title>Day24 紙牌接龍-結算畫面</title>
      <link>https://kabuto412rock.github.io/posts/it-day24/</link>
      <pubDate>Tue, 03 Oct 2023 03:42:16 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day24/</guid>
      <description>前言 目前實作的紙牌接龍還沒有結算畫面，所以今天就來做!
初步思考 製作結算畫面本身不是問題，畢竟畫面沒有要做得超級漂亮的情況下都是沒問題的!
問題是何時跳出結算畫面? 我想到的情形有兩種:
結算牌堆四堆都集完13張的情況 畫面中7牌堆的牌全部已經打開的情況 我認為第一種判斷結算牌堆的方式實作起來比較簡單，接下來實作也會朝這個方向前進。
實作邏輯 製作檢查完成牌組的函數 宣告一個函數checkSolitaireGameDone負責檢查紙牌接龍是否完成。
依序檢查各結算牌堆，若數量不為13就直接回傳 否false 最後就回傳 是true 程式碼如下:
/** * 檢查紙牌接龍是否完成 * @param {CardStacks} cardStacks */ function checkSolitaireGameDone(cardStacks) { for (let i = 0; i &amp;lt; FOUR_SUITS.length; i++) { if (cardStacks[FOUR_SUITS[i]].length !== 13) return false; } return true; } 監控觸發檢查 不意外的又使用到watch這個關鍵字做監控，這部分就是跟Day4的連連看一樣， 當 牌堆cardStacks 發生變化就去觸發檢查，判定完成就使用alert跳出結算訊息。
使用者點擊alert()之後，才會執行重設遊戲的函數resetGame()
// DragDemo.vue watch(cardStacks, (newCardStacks) =&amp;gt; { const isDone = checkSolitaireGameDone(newCardStacks); if (isDone) { alert(`遊戲結束，花費時間: ${gameTime.value} 秒 總分數: ${gameScore.</description>
    </item>
    
    <item>
      <title>Day23 連點2下自動移牌</title>
      <link>https://kabuto412rock.github.io/posts/it-day23/</link>
      <pubDate>Mon, 02 Oct 2023 03:45:32 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day23/</guid>
      <description>前言 今天要實做的是點擊自動移牌的功能也算是昨天提示的延伸，差別只在會實際移動卡牌。
我打算連點移牌功能只做在七牌堆和發牌區，結算牌堆就不提供此功能。
實作過程 處理連點事件 調整發牌區/七牌堆的卡片元件&amp;lt;Card&amp;gt;添加對應的屬性@dblclick=&amp;quot;emit(&#39;card-click&#39;, element)&amp;quot;， 這會讓卡牌元件&amp;lt;Card&amp;gt;被連點兩下(Double Click)時，向父元件發送事件card-click然後攜帶的參數element則是Card物件
// Card { value: 0, // 卡牌對應數值，Ex: 梅花A isOpen: false, // 是否已開牌 } 然後修改上層樣板(DragDemo.vue)的部分:
為了接收card-click事件進行處理，在發牌區的樣板修改成有添加@card-click=&amp;quot;(card) =&amp;gt; clickAutoMove(&#39;dealerStacks&#39;, card) 在七牌堆的樣板，這七行依序添加屬性@dblcick 第一牌堆 @dblclick=&amp;quot;clickAutoMove(&#39;first&#39;, element)&amp;quot; 第二牌堆 @dblclick=&amp;quot;clickAutoMove(&#39;second&#39;, element)&amp;quot; 中間略&amp;hellip; 第七牌堆的屬性 @dblclick=&amp;quot;clickAutoMove(&#39;seventh&#39;, element)&amp;quot; 處理自動移動的邏輯 這邊出現的新函數clickAutoMove(fromName, card)，主要是用來處理自動移動的邏輯，流程如下:
先利用findFollowDeckName找出card可以拖曳到的牌堆名稱，然後依照優先順序排序(結算牌堆排第一)。 如果沒有找到對應的牌堆，則不執行後續。 取出第一個牌堆名稱當作目標牌堆 接著就判斷來源牌堆是發牌堆還是七牌堆，來做不同的處理(修改對應牌組陣列 還有 加分等等) 可以參考下方的程式碼片段:
// DragDemo.vue /** * 自動移動 * @param {String} fromName 來自的牌堆名稱 * @param {Card} card 想移動的牌 */ function clickAutoMove(fromName, card) { const toNames = findFollowDeckName(cardStacks, card).</description>
    </item>
    
    <item>
      <title>Day22 接龍移牌提示</title>
      <link>https://kabuto412rock.github.io/posts/it-day22/</link>
      <pubDate>Sun, 01 Oct 2023 01:10:38 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day22/</guid>
      <description>前言 今天要實作接龍移牌提示，以下是會需要處理的題目:
怎麼取得場上牌的拖曳路線? 找到拖曳路線後，如何顯示要拖曳至哪個地方的提示(文字or動畫)? 取得拖曳路線 目前可知拖曳區塊有7牌堆、發牌區、結算牌堆，其中卡牌可拖曳的方向有:
7牌堆可以內部自拖曳或結算牌堆 發牌區只能拖曳至7牌堆、結算牌堆 結算牌堆只能拖曳至7牌堆 初步分析: 可以先計算可以移入7牌堆、結算牌堆牌尾的撲克牌
預計執行步驟: 計算出7牌堆、結算牌堆各自牌尾後能放什麼牌，儲存在Map 從發牌區/7牌堆/結算牌堆依序判斷可拖曳卡牌的數字是否存在Map中? 是，回傳比對成功的結果: { &amp;#34;可拖曳卡牌所在的牌堆&amp;#34;, &amp;#34;拖曳卡牌在牌堆的位置&amp;#34;, &amp;#34;預計移入的牌堆&amp;#34;} 否，繼續比對下一張直到無牌可比 實際程式碼 參數帶入要計算的全部牌堆，計算回傳每張牌可被移入的牌堆。 因為有可能出現梅花A可以移入結算牌堆或7牌堆的情況，所以實作設計成一張牌只會對應一個牌堆，此例梅花A會優先被移入結算牌堆。
// utils/poker-helper.js /** * 找出7牌堆、結算牌堆各牌尾後要接的牌 * @param {CardStacks} cardstacks * @returns {Map&amp;lt;Number, String&amp;gt;} Map&amp;lt;撲克牌編號, 目標牌堆名稱&amp;gt; */ function findTailCards(cardstacks) { const result = new Map(); // 找出可拖曳至7牌堆尾巴的牌 SEVEN_STACKS.forEach((name) =&amp;gt; { const stack = cardstacks[name]; if (stack.length === 0) { [12, 25, 38, 51].forEach((value) =&amp;gt; { result.set(value, name); }); return; } const lastCard = stack[stack.</description>
    </item>
    
    <item>
      <title>Day21 顯示接龍分數、遊戲時間</title>
      <link>https://kabuto412rock.github.io/posts/it-day21/</link>
      <pubDate>Fri, 29 Sep 2023 23:38:40 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day21/</guid>
      <description>前言 今天預計實作的項目顯示分數、顯示遊玩時間， 但實作顯示分數必須配合實作累計分數的功能，不然分數都不會變動也是尷尬😂。
儲存分數、遊玩時間的變數宣告:
const gameScore = ref(0); const gameTime = ref(0); const gameTimer = ref(null); 實作遊戲分數 實作分數累計規則 先整理出接龍的分數在什麼情況會增加?
從發牌區移出則加10分，因為發牌區的牌不會被重新移入所以不用擔心重複加分。 // DragDemo.vue /** 發牌區移動 */ function dealerMove(evt) { // 略 if(result){ changeOption.value = () =&amp;gt; { // 略 gameScore.value += 10; } } } 7牌堆的牌被打開則加5分，因為被打開的牌不會被蓋回去。 原本程式就會將7牌堆最一張牌設為打開，改判斷最後一張原本是蓋牌才開牌、加5分避免分數重複累加。
// DragDemo.vue watch(cardStacks, (stacks) =&amp;gt; { // 檢查每組牌堆最後一張 validNames.forEach(cardName =&amp;gt; { if (stacks[cardName].length &amp;gt; 0) { const lastCard = stacks[cardName][stacks[cardName].length - 1]; if (!lastCard.isOpen) { lastCard.</description>
    </item>
    
    <item>
      <title>Day20 實作結算牌堆元件(四) 實作移入7牌堆的拖曳&amp;遊戲重置</title>
      <link>https://kabuto412rock.github.io/posts/it-day20/</link>
      <pubDate>Fri, 29 Sep 2023 03:39:17 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day20/</guid>
      <description>前言 今天會先實作結算牌堆的牌要可以拖曳至7牌堆， 另外因為每次要重新開始都要切換頁面或按F5重新整理也會實作一個重置遊戲的按鈕
拖曳結算牌堆的牌 至 7牌堆 原本以為會花點時間想怎麼做，但實際上思考、實作都沒花多少時間就完成。
因為結算牌堆拖曳的牌一次只會拖曳一張，且拖曳到7牌堆的過程判斷基本上抄之前7牌堆自己的拖曳判斷方法就差不多完成，只多了一個先判斷拖曳的目標牌堆是否為七牌堆，甚至不用像其他牌堆拖曳:move還要額外去寫『拖曳成功後要觸發修改陣列』的函數changeOption.vlaue。
以下是對應結算牌堆&amp;lt;FinishedArea &amp;gt;內元件的屬性:move實作程式碼:
// DragDemo.vue /** 結算牌堆移動 */ function finishedCardMove(evt) { const to = getDomName(evt.to); const { futureIndex, element } = evt.draggedContext; let result = validNames.includes(to); // 只能移動至目標牌堆的最後一張牌 result = result &amp;amp;&amp;amp; futureIndex == cardStacks[to].length; // 檢查疊牌順序、花色是否正確 result = result &amp;amp;&amp;amp; checkNextOk(cardStacks[to], element); return result; } 調整樣板&amp;lt;FinishedArea &amp;gt;的屬性:moveCard=&amp;quot;finishedCardMove&amp;quot;即可套用上方的函數。
&amp;lt;!-- DragDemo.vue --&amp;gt; &amp;lt;div class=&amp;#34;text&amp;#34;&amp;gt;結算牌堆&amp;lt;/div&amp;gt; &amp;lt;FinishedArea :fourCards=&amp;#34;cardStacks&amp;#34; :moveCard=&amp;#34;finishedCardMove&amp;#34; @doms=&amp;#34;setFourCardDoms&amp;#34; :change=&amp;#34;cardChange&amp;#34; /&amp;gt; 實作重置遊戲的按鈕 因為遊戲初始化就是寫在onMounted但重設的部分不夠完整，至少並沒有考慮到結算牌堆的部分，舊版初始化程式碼如下:
onMounted(() =&amp;gt; { const data = geneateShuffleDeck(52); const everyIndex = [0, 1, 3, 6, 10, 15, 21, 28]; validNames.</description>
    </item>
    
    <item>
      <title>Day 19 實作結算牌堆元件(三)整合至接龍頁面</title>
      <link>https://kabuto412rock.github.io/posts/it-day19/</link>
      <pubDate>Thu, 28 Sep 2023 03:28:44 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day19/</guid>
      <description>前言 今天會實作發牌區、7牌堆的牌可以拖曳到結算牌堆，且拖曳的過程需遵守結算牌堆的同色疊牌由A至K的規則。
整理重複的函數 先將昨天在DealerAreaView.vue撰寫的程式碼移動到拖曳練習的頁面DragDemo.vue。
樣板的部分是沒什麼問題，只是發現有太多函數宣告出現在DragDemo.vue，所以將常數FOUR_SUITS和判斷結算牌堆規則的checkNextOk2函數先移入工具目錄utils/內的程式碼，DragDemo.vue改用import的方式載入通用的常數、函數。
// DragDemo.vue import { FOUR_SUITS } from &amp;#39;../utils/constants&amp;#39;; import { geneateShuffleDeck, checkNextOk, checkNextOk2 } from &amp;#34;../utils/poker-helper&amp;#34;; 設定結算牌堆用的資料 在原本的cardStack中添加針對結算牌堆四花色的撲克牌陣列
// DragDemo.vue const cardStacks = reactive({ // 略... /** @type {Card[]} */ club: [], /** @type {Card[]} */ diamond: [], /** @type {Card[]} */ heart: [], /** @type {Card[]} */ spade: [] }); 因為&amp;lt;FinishedArea /&amp;gt;的屬性:fourCard只有要求傳入的物件需要有對應花色名稱的KEY就可以，沒有硬性要求不能有其他屬性， 所以樣板的傳值我就簡單設定cardStacks傳入，如下程式碼:
&amp;lt;!-- DragDemo.vue --&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div class=&amp;#34;text&amp;#34;&amp;gt;發牌區&amp;lt;/div&amp;gt; &amp;lt;DealerArea :deck=&amp;#34;cardStacks.dealerStacks&amp;#34; :moveCard=&amp;#34;dealerMove&amp;#34; /&amp;gt; &amp;lt;div class=&amp;#34;text&amp;#34;&amp;gt;結算牌堆&amp;lt;/div&amp;gt; &amp;lt;FinishedArea :fourCards=&amp;#34;cardStacks&amp;#34; @doms=&amp;#34;setFourCardDoms&amp;#34; :change=&amp;#34;cardChange&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; 在DragDemo.</description>
    </item>
    
    <item>
      <title>Day 18 實作結算牌堆元件(二) 整合拖曳相容不同規則</title>
      <link>https://kabuto412rock.github.io/posts/it-day18/</link>
      <pubDate>Wed, 27 Sep 2023 06:51:23 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day18/</guid>
      <description>前言 昨天完成結算牌堆樣版的部分，今天接著處理整合拖曳到接龍之前的步驟， 先調整結算牌堆的內部結構、方法。
調整結算牌堆 FinishedArea 先調整結算牌堆&amp;lt;FinishedArea /&amp;gt;內部需要的props結構，就底下這三種:
props.fourCards對應四個牌堆的陣列 props.moveCard對應&amp;lt;draggable&amp;gt;元件的屬性:move判斷是否可以拖曳成功的函數 props.change對應&amp;lt;draggable&amp;gt;內的列表更新時觸發的函數(這部分等等再說明) 程式碼如下:
// FinishedArea.vue const props = defineProps({ fourCards: { type: Object, required: true, validator: (value) =&amp;gt; { return ( value.hasOwnProperty(&amp;#39;club&amp;#39;) &amp;amp;&amp;amp; value.hasOwnProperty(&amp;#39;diamond&amp;#39;) &amp;amp;&amp;amp; value.hasOwnProperty(&amp;#39;heart&amp;#39;) &amp;amp;&amp;amp; value.hasOwnProperty(&amp;#39;spade&amp;#39;) ); }, }, moveCard: { type: Function, default: () =&amp;gt; { return false; } }, change: { type: Function, default: () =&amp;gt; { return false; } } }) 然後結算牌堆就像發牌區一樣，卡牌陣列都是由外部props傳入且props的陣列內容都會變動， 所以也需要watch監控props.fourCards變化調整元件內的fourCards內的值。
// FinishedArea.vue const fourCards = ref({ club: [], diamond: [], heart: [], spade: [], }); watch(props.</description>
    </item>
    
    <item>
      <title>Day 17 實作結算牌堆元件(一)樣板&amp;資料結構</title>
      <link>https://kabuto412rock.github.io/posts/it-day17/</link>
      <pubDate>Tue, 26 Sep 2023 03:54:14 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day17/</guid>
      <description>前言 今日要製作結算牌堆，跟中間的7疊牌不同，結算牌堆只有4堆且只能允許同花色疊在上面，必須由小到大(A-&amp;gt;K)放上去，放上去的牌會擋住底下的牌。
修正發牌區拖曳Bug 在開發今日功能前，測試遊玩發牌區到中間七牌堆發現能任意插到七牌堆的中間， 在函數dealerMove中補上evt.draggedContext.futureIndex == cardStacks[to].length的判斷後才正常，以下是修正後的程式碼:
/** 發牌區移動 */ function dealerMove(evt) { const to = getDomName(evt.to); const dealerCard = evt.draggedContext.element; // 只能移動至目標牌堆的最後一張牌 let result = futureIndex == cardStacks[to].length; // 檢查疊牌順序、花色是否正確 result = result &amp;amp;&amp;amp; checkNextOk(cardStacks[to], dealerCard); if (result) { changeOption.value = () =&amp;gt; { cardStacks.dealerStacks = cardStacks.dealerStacks.filter(card =&amp;gt; card.value !== dealerCard.value); changeOption.value = null; }; } return result; } 製作結算牌堆樣板 看一下草稿圖，接著想像畫面應該會有四個長方塊並排，四個長方都有個底圖對應花色， 底圖上方都可以擺一張牌。
跟製作發牌區&amp;lt;DealerArea&amp;gt;相同，打算先做出元件&amp;lt;FinishedArea&amp;gt;在整合進原本的接龍區塊， 以下是目前的樣板程式碼:
// FinishedArea.vue &amp;lt;template&amp;gt; &amp;lt;div style=&amp;#34;display: flex;&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;card club&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;card diamond&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;card heart&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;card spade&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; 補上拖曳的樣板前，這部分會需要考慮四個牌堆的資料， 所以資料結構就設計成四個花色各自對應1個Card陣列的狀態</description>
    </item>
    
    <item>
      <title>Day16 接龍發牌區功能實作(三)拖曳與疊牌區整合</title>
      <link>https://kabuto412rock.github.io/posts/it-day16/</link>
      <pubDate>Mon, 25 Sep 2023 07:05:48 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day16/</guid>
      <description>前言 今天要來處理&amp;lt;DealerArea&amp;gt;內的元素如何整合拖曳移動到7個牌堆， 這部分會拆成2個部分來看:
可將&amp;lt;DealerArea&amp;gt;卡牌移入至牌堆上方，且遵守移動遊戲規則的條件 其他牌堆的牌無法移入&amp;lt;DealerArea&amp;gt;牌堆中 實作將&amp;lt;DealerArea&amp;gt;卡牌移入牌堆 這邊在DragDemo.vue中設定提供給發牌區&amp;lt;DealerArea&amp;gt;判斷用的:move函數，因為這個函數不像函數limitLocalMove函數是同時給7個牌堆各自使用，所以可以看到沒有特別提到from的部分，因為不用特別想就可以知道一定是來自(from)發牌區。
如果不清楚limitLocalMove是做什麼的，這部分從 第10天~第12天 的文章都有提到，主要是對應&amp;lt;draggable&amp;gt;元件的:move函數判斷使否可拖曳成功。
檢查疊牌遊戲規則的部分就由函數checkNextOk判斷，幾天前寫好的函數重新複用了👍 這邊只要result回傳true就會讓卡牌移動自動產生變化。
// DragDemo.vue /** 發牌區移動 */ function dealerMove(evt) { const to = getDomName(evt.to); const dealerCard = evt.draggedContext.element; // 檢查疊牌順序、花色是否正確 const result = checkNextOk(cardStacks[to], dealerCard); return result; } 樣板的部分就是小調整而已:
// DragDemo.vue &amp;lt;DealerArea :deck=&amp;#34;cardStacks.dealerStacks&amp;#34; :moveCard=&amp;#34;dealerMove&amp;#34; /&amp;gt; 結果看起來拖曳過去是沒問題，但本該移動過去的元素也仍留在原地， 如下圖GIF出現了2個梅花9，此為禁忌的二重身問題💀必須修正。 修正陰魂不散的元素 因為還是有拖曳成功，只是舊資料殘留在發牌區的陣列cardStacks.dealerStacks，所以只要在拖曳完成時，將發牌區的陣列去除已經發出去的那一張牌即可，以下是修正後的程式碼:
// DragDemo.vue function dealerMove(evt) { const to = getDomName(evt.to); const dealerCard = evt.draggedContext.element; // 檢查疊牌順序、花色是否正確 const result = checkNextOk(cardStacks[to], dealerCard); if (result) { changeOption.</description>
    </item>
    
    <item>
      <title>Day15 接龍發牌區功能實作(二)拖曳功能及CSS發牌動畫</title>
      <link>https://kabuto412rock.github.io/posts/it-day15/</link>
      <pubDate>Sat, 23 Sep 2023 12:19:58 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day15/</guid>
      <description>前言 今天要來補強昨日缺少的拖曳功能和將整個頁面封裝成提供整合至接龍遊戲的元件發牌區。
移牌區改為可拖曳 首先將移牌區的部分調整成從原生HTML元素div替換成這幾天都在使用draggable元件，程式碼如下:
&amp;lt;!-- 移牌區 - 左邊水平疊牌最多三張 --&amp;gt; &amp;lt;draggable :list=&amp;#34;canTakeCards&amp;#34; group=&amp;#34;pokers&amp;#34; itemKey=&amp;#34;value&amp;#34; class=&amp;#34;list-group&amp;#34; &amp;gt; &amp;lt;template #item=&amp;#34;{ element, index }&amp;#34;&amp;gt; &amp;lt;Card :value=&amp;#34;element.value&amp;#34; :isOpen=&amp;#34;element.isOpen&amp;#34; /&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/draggable&amp;gt; 發牌區調整動畫 雖然移牌區感覺在加牌的時候應該要套用動畫，但無奈vue.draggable.next的transition-group有Bug存在且已被官方棄養，在issue也有許多類似問題issue with transition-group in composition API就不細講。
不論是Vue2使用的vue.draggable或Vue3使用的vue.draggable.next都是對SortableJS進行包裝的容器，基本上不滿意的話只能自己重封裝實現只是CP值不高，所以我不考慮這麼做。
這不代表選擇放棄動畫，打算以CSS來實現以下動畫效果。 實際調整 首先調整樣板程式碼，主要是針對有牌時添加對應的class&amp;quot;card-back animtion&amp;quot;，也順便將點擊事件@click移到外層div:
&amp;lt;!-- 發牌堆 --&amp;gt; &amp;lt;div class=&amp;#34;card-box&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;card &amp;#34; style=&amp;#34;visibility: hidden;&amp;#34;&amp;gt; &amp;lt;div style=&amp;#34;visibility: visible; width: 100%;height: 100%;&amp;#34; @click=&amp;#34;clickCard&amp;#34;&amp;gt; &amp;lt;Transition name=&amp;#34;slide-left&amp;#34;&amp;gt; &amp;lt;div v-if=&amp;#34;deckState == &amp;#39;empty&amp;#39;&amp;#34;&amp;gt;無牌可用&amp;lt;/div&amp;gt; &amp;lt;div v-else-if=&amp;#34;deckState == &amp;#39;full&amp;#39;&amp;#34; class=&amp;#34;card&amp;#34;&amp;gt;重新循環&amp;lt;/div&amp;gt; &amp;lt;div v-else-if=&amp;#34;deckState == &amp;#39;normal&amp;#39;&amp;#34; class=&amp;#34;card-back animation&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/Transition&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 添加對應CSS實現點擊後往左快速位移一次的效果</description>
    </item>
    
    <item>
      <title>Day14 接龍發牌區功能實作(一)發牌循環</title>
      <link>https://kabuto412rock.github.io/posts/it-day14/</link>
      <pubDate>Sat, 23 Sep 2023 00:33:59 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day14/</guid>
      <description>為了實現接龍發牌區功能，必須先思考如何讓撲克牌循環利用，這部分程式碼我是先拆一個頁面來練習實作，避免單一頁面的程式碼邏輯太過混亂。
發牌區的樣板 今日實作的目標會是一個左邊移牌區右邊發牌堆結合在一起的， 點擊發牌堆會將牌發到移牌區顯示，移牌區最多同時顯示三張牌。 實作的樣板程式碼 // DealerAreaView.vue &amp;lt;GameBoard&amp;gt; &amp;lt;div class=&amp;#34;text&amp;#34;&amp;gt;發牌區&amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;display: grid; grid-template-columns: 1.5fr 1fr; gap:3rem; width: fit-content;&amp;#34;&amp;gt; &amp;lt;!-- 移牌區 - 左邊水平疊牌最多三張 --&amp;gt; &amp;lt;div style=&amp;#34;display: grid; grid-template-columns: repeat(3, 3rem);&amp;#34;&amp;gt; &amp;lt;div v-for=&amp;#34;card in canTakeCards&amp;#34; :key=&amp;#34;card.value&amp;#34;&amp;gt; &amp;lt;Card :value=&amp;#34;card.value&amp;#34; :isOpen=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 發牌堆 --&amp;gt; &amp;lt;div class=&amp;#34;card-box&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;card&amp;#34; style=&amp;#34;visibility: hidden;&amp;#34;&amp;gt; &amp;lt;div style=&amp;#34;visibility: visible; width: 100%;height: 100%; &amp;#34;&amp;gt; &amp;lt;Transition name=&amp;#34;slide-left&amp;#34;&amp;gt; &amp;lt;div v-if=&amp;#34;deckState == &amp;#39;empty&amp;#39;&amp;#34;&amp;gt;無牌可用&amp;lt;/div&amp;gt; &amp;lt;div v-else-if=&amp;#34;deckState == &amp;#39;full&amp;#39;&amp;#34; class=&amp;#34;card&amp;#34; @click=&amp;#34;clickCard&amp;#34;&amp;gt;重新循環&amp;lt;/div&amp;gt; &amp;lt;div v-else-if=&amp;#34;deckState == &amp;#39;normal&amp;#39;&amp;#34; @click=&amp;#34;clickCard&amp;#34; class=&amp;#34;card-back&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/Transition&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/GameBoard&amp;gt; 可以注意到發牌堆使用&amp;lt;Transition&amp;gt;包裹，裡面的元件使用v-if和v-else-if去判斷三種情況顯示元件， 這邊使用到的deckState是一個計算結果。</description>
    </item>
    
    <item>
      <title>Day13 牌尾自動翻牌、限制疊牌順序</title>
      <link>https://kabuto412rock.github.io/posts/it-day13/</link>
      <pubDate>Fri, 22 Sep 2023 04:58:26 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day13/</guid>
      <description>今日預計實作項目:
☑️ 只能對牌尾進行翻牌 ☑️ 牌尾自動翻牌 ☑️ 限制疊牌順序 只能對牌尾進行翻牌 新增函數openCard(cards, element)因為需要確認點擊卡牌確實是在牌尾， 所以需要參數cards對應原本的卡牌陣列、參數element對應點擊的卡牌元素。
檢查牌尾就單純檢查element的數字(value)是否跟陣列cards的最後一筆數字相同， 在這邊的情況不用擔心cards的長度為0，因為所在牌堆沒有卡牌自然就不會渲染使用openCard函數的&amp;lt;Card&amp;gt;元件。
/** 開牌函數 * @param {Card[]} cards * @param {Card} element */ function openCard(cards, element) { let same = cards[cards.length - 1].value == element.value; if (same) { element.isOpen = true; } } 調整每一個&amp;lt;Card&amp;gt;元件的@click監聽，以下以第1牌堆的樣板舉例:
&amp;lt;Card :value=&amp;#34;element.value&amp;#34; :isOpen=&amp;#34;element.isOpen&amp;#34; @click=&amp;#34;openCard(cardStacks.first, element)&amp;#34; /&amp;gt; 第2、3牌堆只需將cardStacks.first中的first替換成對應陣列second和third， 雖然下一步牌尾會自動翻牌不需要人去手動翻開、但還是要避免有人去對非牌尾的開牌。
牌尾自動翻牌 這部分我是依賴Vue本身的watch去監聽牌堆的變化， 跟上一個步驟很像的取得最後一張牌lastCard並打開isOpen = true，不一樣的是需要真的檢查牌堆是否為空的情況，避免出現undefined的Error
watch(cardStacks, (stacks) =&amp;gt; { // 檢查每組牌堆最後一張 [&amp;#39;first&amp;#39;, &amp;#39;second&amp;#39;, &amp;#39;third&amp;#39;].forEach(cardName =&amp;gt; { if (stacks[cardName].</description>
    </item>
    
    <item>
      <title>Day 12 實作拖曳卡牌只能置放到目標牌堆的牌尾、蓋牌無法拖曳</title>
      <link>https://kabuto412rock.github.io/posts/it-day12/</link>
      <pubDate>Thu, 21 Sep 2023 04:36:25 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day12/</guid>
      <description>今天預計實作接龍紙牌的拖曳規則
☑️ 拖曳卡牌只能置放到目標牌堆的牌尾 -&amp;gt; 只能置放至目標最後 ☑️ 牌堆只有打開的牌才能進行拖曳 -&amp;gt; 蓋牌無法拖曳 拖曳卡牌只能置放到目標牌堆的牌尾 檢查方式很簡單，首先將昨日的:move函數內的變數result判斷先改成用let宣告， 因為不能任意插入前面的順序，所以增加判斷只有新目標位置futureIndex等於目標牌堆陣列的長度cardStacks[to].length時才可以進行移動。
如果要移動到的目標牌堆沒有牌，futureIndex就需要等於0 如果要移動到目標牌堆有1張牌，futureIndex就需要等於1 總之目標牌堆有N張牌，futureIndex就要為N，以此類推&amp;hellip; 實際程式碼 function limitLocalMove(evt) { // 限制同個牌堆無法拖曳 let result = evt.from !== evt.to; // 取得牌堆的來源、目標名稱，對應reactive`cardStacks`內的名稱 const from = getDomName(evt.from); const to = getDomName(evt.to); const { index, futureIndex } = evt.draggedContext; // 只能移動目標牌堆的最後一張牌 result = result &amp;amp;&amp;amp; futureIndex == cardStacks[to].length; if (result) { // 中間略 } return result; } 牌堆只有打開的牌才能進行拖曳 先初始化改為39張牌均分給3個牌堆且將所有牌都闔上， 這樣接下來才能測試闔牌狀態不能拖曳。
const cardStacks = reactive({ first: [], second: [], third: [] }); onMounted(() =&amp;gt; { const data = geneateDeck(39, false); cardStacks.</description>
    </item>
    
    <item>
      <title>Day 11 拖曳紙牌的效果(三)如何一次拖曳多張卡牌</title>
      <link>https://kabuto412rock.github.io/posts/it-day11/</link>
      <pubDate>Wed, 20 Sep 2023 03:25:18 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day11/</guid>
      <description>今日預計只實作如何一次拖曳 多張卡牌
多張卡牌拖曳的考察研究 這部分可能會讓很多人(我)失望，因為vue.draggable.next最近一次的合併更新在2021年8月， 所以目前Vue3無法像原本Vue2能使用vue.draggable的Multi-drag的擴充功能，所以我捨棄使用套件原生多筆拖曳的想法和 拖曳多張牌完美的畫面效果。
如果願意改變資料結構為巢狀Vue3版本還是有辦法對巢狀物件進行一次性的拖曳，但對我來說在未來資料處理的靈活性降低又提高判斷卡牌順序的複雜度因此不考慮。
想法邏輯 從來源牌堆先拖曳一張牌A移動到目標牌堆的指定位置 將來源牌堆中A牌後的剩餘卡片複製到目標牌堆的指定位置後方 刪除來源牌堆原A位置後的剩餘元素 實作後發現其實可以先複製一份來源牌堆、目標牌堆移動後的結果，後續處理會更為靈活。
實作邏輯 在:move對應的函數中判斷可拖曳時，產生『若拖曳成功後，來源/目標陣列的新狀態』並封裝成一個箭頭函數儲存至ref變數changeOption。 function limitLocalMove(evt) { // 限制同個牌堆無法拖曳 const result = evt.from !== evt.to; if (result) { // 取得牌堆的來源、目標名稱，對應reactive`cardStacks`內的名稱 const from = getDomName(evt.from); const to = getDomName(evt.to); const draggedContext = evt.draggedContext const { index, futureIndex } = draggedContext; // 產生多筆拖曳後，來源牌堆、目的牌堆的陣列變動後的結果 const newFromCards = cardStacks[from].slice(0, index); const newToCards = [ ...cardStacks[to].slice(0, futureIndex), ...cardStacks[from].slice(index), ...cardStacks[to].slice(futureIndex) ]; // 將變動牌堆的函數暫存，預計等到拖曳完成後執行 changeOption.value = () =&amp;gt; { cardStacks[from] = newFromCards; cardStacks[to] = newToCards; changeOption.</description>
    </item>
    
    <item>
      <title>Day 10 拖曳紙牌的效果(二)限制內部拖曳</title>
      <link>https://kabuto412rock.github.io/posts/it-day10/</link>
      <pubDate>Tue, 19 Sep 2023 03:49:59 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day10/</guid>
      <description>今天來研究兩個列表的拖曳和如何限制列表的拖曳，學習內容主要來自vue.draggable文件的內容和親身實作進行分析。
先實現兩個列表的拖曳 昨天已學過如何製作單一列表的拖曳，先將相同的&amp;lt;draggable&amp;gt;內容複製往下貼， 複製的另一個&amp;lt;draggable&amp;gt;只需要調整屬性:list成想要對應的另一個陣列，並且兩個&amp;lt;draggable&amp;gt;添加相同的屬性group則自動實現兩個列表拖曳的關聯。
&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;draggable :list=&amp;#34;firstCardStack&amp;#34; group=&amp;#34;pokers&amp;#34; itemKey=&amp;#34;value&amp;#34;&amp;gt; &amp;lt;template #item=&amp;#34;{ element, index }&amp;#34;&amp;gt; &amp;lt;Card :value=&amp;#34;element.value&amp;#34; :isOpen=&amp;#34;element.isOpen&amp;#34; /&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/draggable&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;draggable :list=&amp;#34;secondCardStack&amp;#34; group=&amp;#34;pokers&amp;#34; itemKey=&amp;#34;value&amp;#34;&amp;gt; &amp;lt;template #item=&amp;#34;{ element, index }&amp;#34;&amp;gt; &amp;lt;Card :value=&amp;#34;element.value&amp;#34; :isOpen=&amp;#34;element.isOpen&amp;#34; /&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/draggable&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; 如何限制列表的拖曳 前面已先實現了兩列表的拖曳，但為求理解仍保留著@change=&amp;quot;console.log&amp;quot;，在限制拖曳之前，我必須先觀察拖曳完成前能得到的資訊，所以我必須先觀察變動後@change實際印了什麼有用的資訊。
因為如果只是要單純限制一個&amp;lt;draggable&amp;gt;不能拖曳移入移出，只需要設定屬性:move=&amp;quot;() =&amp;gt; false&amp;quot;，但我想做的不僅僅如此。
不同牌堆的移動 將牌堆1的梅花A移動到牌堆2後，可觀察到開發人員工具的Console依序印出兩個物件:
內含added屬性，且added物件本身包含陣列移動的元素element和目標陣列內的新位置newIndex 內含removed屬性，且removed物件本身包含陣列移動的元素element和原陣列內的舊位置oldIndex 這兩個@change是由各自受影響的Draggable所觸發，但內含的元素是相同的
同牌堆的移動 將同牌堆的第三張牌(梅花3)移動到第六張牌(梅花6)的位置，則只印出一個包含屬性moved的物件， 且moved物件本身包含陣列移動的元素本身element和新位置newIndex和舊位置oldIndex的資訊。 從此可推測，如果要禁止同牌堆內的移動，只需要禁止moved的行為。
禁止同牌堆的內部拖曳 從官方文件中可查到屬性:move對應的函數只要回傳false即可取消此次的拖曳。
function onMoveCallback(evt, originalEvent){ ... // return false; — for cancel } 這邊我只印出參數evt得到的資料，內容跟@change不一樣的超乎想像多資訊😫，而且跟@change不同的是，這個:move對應函數只要拖曳卡牌到某一張卡的上面就會觸發一次 但好險&amp;hellip;如果只需要判斷是否在同個牌堆只需要看evt內的屬性from, to是否為相同DOM元素即可， 因為from、to分別代表拖曳的元素是 來自哪一個draggable元件 和 即將放置在哪一個draggable元件。</description>
    </item>
    
    <item>
      <title>Day 09 拖曳紙牌的效果(一)</title>
      <link>https://kabuto412rock.github.io/posts/it-day9/</link>
      <pubDate>Mon, 18 Sep 2023 05:13:22 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day9/</guid>
      <description>玩紙牌接龍最重要的就是卡牌會移來移去，之前都是用點的移動定點， 今天來試試看如何撰寫拖曳紙牌的功能。
安裝依賴 因為重頭學習理解拖曳，對我來說太麻煩也太無聊， 乾脆就使用現成的套件Vue.Draggable吧!
因為使用的是Vue3專案，所以必須安裝有標註next的版本。
npm i -S vuedraggable@next 單一列表的拖曳使用 我也還在理解該套件中，接下來的過程會盡可能去蕪存菁，但不失細節。
首先一定要先引入vuedraggable，如下所示:
&amp;lt;script setup&amp;gt; import draggable from &amp;#39;vuedraggable&amp;#39; // ...other template &amp;lt;/script&amp;gt; 樣板的部分則如下:
&amp;lt;template&amp;gt; &amp;lt;draggable :list=&amp;#34;firstCardStack&amp;#34; itemKey=&amp;#34;value&amp;#34; @change=&amp;#34;console.log&amp;#34; style=&amp;#34;display: grid; grid-template-columns: repeat(13, 3rem);&amp;#34;&amp;gt; &amp;lt;template #item=&amp;#34;{ element, index }&amp;#34;&amp;gt; &amp;lt;Card :value=&amp;#34;element.value&amp;#34; :isOpen=&amp;#34;element.isOpen&amp;#34; /&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/draggable&amp;gt; &amp;lt;/template&amp;gt; 這樣的寫法在通常就已可運用，接下來讓我們來逐一理解&amp;lt;draggable&amp;gt;每個欄位的意義和預設行為&amp;hellip;
:list 首先:list內設定的是一個參考到陣列的ref或reactive變數，只要裡面參考到的是Array即可， 這可以讓&amp;lt;draggable&amp;gt;明白當列表項目被拖曳移動時自動修改的對象。
// 此處genearateDeck(20, true)會回傳20個物件的Array物件 const firstCardStack = ref(geneateDeck(20, true)); // 為求簡單也能寫成底下這樣 // const firstCardStack = ref([]); itemKey屬性 第二個重要的屬性是itemKey，代表前面陣列中每一個元素的唯一值，基本上就跟v-for內用到的:key有相同作用，可讓元件從itemKey明白內部元素的差異進而去做列表更新。
此處會設定itemKey=&amp;quot;value&amp;quot;，是因為參考的陣列firstCardStack每一個元素的構造如下:
{ value: number, // 撲克牌值，Ex: 0 對應 ♣A isOpen: boolean // 開牌狀態，Ex: false 對應 蓋牌樣式 } 嘗試過不添加itemKey仍可拖曳且參考的陣列有更新，但會發生UI不會刷新的窘境🤣</description>
    </item>
    
    <item>
      <title>Day 08 牌堆的卡牌移動動畫</title>
      <link>https://kabuto412rock.github.io/posts/it-day8/</link>
      <pubDate>Sat, 16 Sep 2023 07:22:58 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day8/</guid>
      <description>重點提醒: 沒有真的成功實作卡牌無中斷的移動 在實作的過程中遇到了一些問題，找到替代方案先記錄下來。
最初的思路 在前一篇文章中，我們已經完成了牌堆的製作，接下來我們要來製作牌堆的卡牌移動動畫。 在開始實作之前，我必須決定要用CSS或是JS實現?
如果牌堆的位置永遠是固定的，或許可以用CSS來實現，但是我們要移動的是牌堆位置不一定永遠在那， 而且牌堆的卡牌數量是不固定的，更加深了預設的座標位置，所以我想這必須用JS來實現， 至少需要JS取得動態元素的位置。
動畫的實作 第一個問題對我來說是，我要怎麼知道卡牌的位置? 起始和結束的位置都是不固定的，所以我必須要先取得卡牌的位置，才能夠進行動畫的實作。
取得當前牌堆的位置的方法有很多種，我在這邊使用的是getBoundingClientRect()， 這個方法可以取得當前元素的相對位置+寬高，但是這個方法是在DOM上的，所以我利用const cardBox = ref(null)設定一個參考， Vue3會自動找到template中使用ref=&amp;quot;cardBox&amp;quot;的元素，並且將其綁定到cardBox上，這樣我就可以在&amp;lt;script setup&amp;gt;中使用cardBox.value來取得HTML元素本身。
因為元件渲染掛載畫面上便會觸發onMounted事件，所以我在onMounted中取得元素的位置，並且透過emit傳遞卡片的絕對位置給父元件。
至於為什麼是絕對位置，因為我們要移動的是卡片，而不是牌堆，所以我們必須要知道卡片的絕對位置，才能夠進行移動。 雖然後來我失敗了，但是我還是想記錄一下這個方法，因為我覺得這個方法還是很有用的。
// CardColumn.vue &amp;lt;script setup&amp;gt; // ... const cardBox = ref(null); onMounted(() =&amp;gt; { const rect = cardBox.value.getBoundingClientRect(); const x = window.scrollX + rect.left; const y = window.scrollY + rect.top; emit(&amp;#39;position&amp;#39;, { x, y }); }) &amp;lt;/script&amp;gt; &amp;lt;template &amp;gt; &amp;lt;div class=&amp;#34;card-box&amp;#34; :class=&amp;#34;{ &amp;#39;empty-card-box&amp;#39;: isEmpty }&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;card&amp;#34; style=&amp;#34;visibility: hidden;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;visibility: visible; position: absolute; z-index: 5;&amp;#34; ref=&amp;#34;cardBox&amp;#34;&amp;gt; &amp;lt;div style=&amp;#34;; display: grid; grid-template-rows: repeat(13, 2rem);&amp;#34;&amp;gt; &amp;lt;Card v-for=&amp;#34;(card, index) in cards&amp;#34; @click=&amp;#34;(event) =&amp;gt; onClick(event.</description>
    </item>
    
    <item>
      <title>Day 07 卡牌垂直重疊</title>
      <link>https://kabuto412rock.github.io/posts/it-day7/</link>
      <pubDate>Fri, 15 Sep 2023 23:48:02 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day7/</guid>
      <description>今日完成目標 多張卡牌實現垂直重疊，但露出非交疊的部分 垂直重疊 為了產生重疊的效果，個人覺得最酷的方式應該是使用CSS的grid排版， 所以在這之前我利用一個GRID GARDEN的網站練習了一下。
原本問ChatGPT是得知用每一張卡堆疊都還要套用不同的CSS，如果要多一張牌就要多一個class，或是用sass的寫法達成，但以上這些我都不想要，一來太麻煩、二來sass還要額外引入新依賴，畢竟我只是想堆疊卡牌而已。
接著說明實際我達成的方式是靠display: grid;要求格狀排列，然後設定grid-template-rows為 repeat(13, 3rem);，這樣就可以讓每一張牌所在的格子都只有3rem的高度，設定13是因為我認為這樣垂直重疊排列卡牌最多只有13張，畢竟紙牌接龍不同花色暫時串再一起也就13張，在現實還是虛擬我的認知都是這樣，當然在設定比13高一點也不會影響，但如果出現第14、15張就會有卡牌不重疊，這點還請注意。
那為什麼達成重疊呢?我在容器內裝13個元件，每一個元件都只裝一張牌，且元件高度限制都在3rem，但實際元件 牌的高度是超過3rem，所以當我裝入第二張牌就會擋住第一張牌，讓第一張牌只露出3rem的高度，以此類推，最後一張牌則會露出全部。
// CardColumn.vue &amp;lt;template &amp;gt; &amp;lt;div class=&amp;#34;card-box&amp;#34; :class=&amp;#34;{ &amp;#39;empty-card-box&amp;#39;: isEmpty }&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;card&amp;#34; style=&amp;#34;visibility: hidden;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div style=&amp;#34;visibility: visible; position: absolute; z-index: 1;&amp;#34;&amp;gt; &amp;lt;div v-if=&amp;#34;isEmpty&amp;#34;&amp;gt;沒牌&amp;lt;/div&amp;gt; &amp;lt;div v-else style=&amp;#34;; display: grid; grid-template-rows: repeat(13, 3rem);&amp;#34;&amp;gt; &amp;lt;Card v-for=&amp;#34;(card, index) in cards&amp;#34; @click=&amp;#34;onClick&amp;#34; :key=&amp;#34;card.value&amp;#34; :value=&amp;#34;card.value&amp;#34; :isOpen=&amp;#34;card.isOpen&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; 額外補充可以注意到card-box內第一個元素是用來稱基本的寬高， 所以第二個元素我則讓他設定position: absolute這樣可以讓其中的格狀排列不會受到第一個元素的影響也不會影響到外部元素。
若少掉position: absolute的話，會變成底下這樣: 本日小結 原本今天是要用水平堆疊，但看了撲克才發現接龍平常都是玩垂直的&amp;hellip;
至於卡牌移動則留在明天吧，因為堆疊卡牌的關係讓我意識到沒有我想像動畫的只是水平移動那麼簡單。
程式碼: https://github.com/kabuto412rock/ithelp-pokergame/tree/day07
參考資料 GRID GARDEN CSS Grid Layout </description>
    </item>
    
    <item>
      <title>Day 06 實現自訂義牌堆</title>
      <link>https://kabuto412rock.github.io/posts/it-day6/</link>
      <pubDate>Fri, 15 Sep 2023 04:08:21 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day6/</guid>
      <description>今日目標 研究如何製作牌堆 製作牌堆 製作CardBox元件負責用來擺放卡片的容器，所以結構上就只是比原本卡片元件的稍寬，所以設計成可放子元件進去的樣板，然後當沒放牌時會產生跟牌一個寬高的隱藏區塊到slot裡面。
// CardBox.vue &amp;lt;template &amp;gt; &amp;lt;div class=&amp;#34;card-box&amp;#34;&amp;gt; &amp;lt;slot&amp;gt; &amp;lt;div class=&amp;#34;card&amp;#34; style=&amp;#34;visibility: hidden;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/slot&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; 所以目前首頁是長這樣，放了兩個空的CardBox佔位置。
// HomeView.vue &amp;lt;div style=&amp;#34;display: grid; grid-template-columns: 1fr 1fr;&amp;#34;&amp;gt; &amp;lt;CardBox&amp;gt;&amp;lt;/CardBox&amp;gt; &amp;lt;CardBox&amp;gt;&amp;lt;/CardBox&amp;gt; &amp;lt;/div&amp;gt; 接著思考如何實作卡牌從A點發到B點，看著畫面思考發現， 不如今天就來實作兩邊卡堆點擊後會移動到對方卡堆的功能。
這邊為了簡單驗證想法，定義函數geneateDeck(5, true)生成五張卡牌依序是梅花A~5(設為開牌)， 我預計實驗兩個卡堆，所以函數也就設計以下兩個非常相似的函數， 功用正是將卡堆的最後一張卡彈出，並推到另一個牌堆。
// HomeView.vue const fstCards = ref(geneateDeck(5, true)); const secondCards = ref([]); const moveCardFromAToB = () =&amp;gt; { const card = fstCards.value.pop(); if (card === undefined) return; secondCards.value.push(card); }; const moveCardFromBToA = () =&amp;gt; { const card = secondCards.</description>
    </item>
    
    <item>
      <title>Day 05 引入Vue Router切換頁面</title>
      <link>https://kabuto412rock.github.io/posts/it-day5/</link>
      <pubDate>Thu, 14 Sep 2023 03:20:17 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day5/</guid>
      <description>因為想留著昨天完成的撲克牌連連看，預計將不同遊戲的頁面可以做保留並切換， 所以我打算在做牌堆之前，首先應該要了解Vue3在路由頁面的實作是如何切換頁面。
引入 Vue Router 接下來步驟我是參考『直接使用npm create vue@latest指令產生預設攜帶有用Vue Router專案的檔案架構』 下去調整的，所以步驟草率請敬請見諒。
安裝依賴Vue Router npm install vue-router@4 在src底下新增兩個資料夾views和router 在views資料夾底下新增兩個頁面檔Game1View.vue和HomeView.vue src ├─App.vue ├─main.js ├─views | ├─Game1View.vue # 撲克連連看 | └─HomeView.vue # 首頁 ├─utils | ├─constants.js | └─poker-helper.js ├─router | └─index.js ├─components | ├─Card.vue | ├─FoxyHeader.vue | ├─GameBoard.vue | 略... 如果想知道是怎麼產生樹狀目錄，我是在src目錄下執行npx treer -e ./result.txt 便會 將樹狀結構寫到當前的result.txt文件中
定義路由應對應的元件，routes的部分可以有預先載入的功能 // router/index.js import { createRouter, createWebHistory } from &amp;#39;vue-router&amp;#39; import HomeView from &amp;#39;../views/HomeView.vue&amp;#39; const router = createRouter({ history: createWebHistory(import.</description>
    </item>
    
    <item>
      <title>Day 04 調整翻牌效果&amp;實作洗牌&amp;外加撲克牌連連看</title>
      <link>https://kabuto412rock.github.io/posts/it-day4/</link>
      <pubDate>Wed, 13 Sep 2023 06:25:37 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day4/</guid>
      <description>改變翻牌效果 研究Transition的文件後發現跟我想像的動畫變換不同，官方用法&amp;lt;Transition&amp;gt;&amp;lt;/Transition&amp;gt; 包裹內的新舊元件其中一個在動畫過程會先被移除掉或新增，但我先前設計好的CSS會是兩個元素都存在只是一個會被轉到CSS效果轉到背後，因此我的水平翻轉動畫需要兩個元素都存在HTML上。
為了在時間內完成，我打消原本水平翻轉的作法，我改採Transition結合v-if的方式去顯示卡牌正反兩面， 發現用漸進式出現消失也是不錯的效果，以下是樣板的改變:
// Card.vue &amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;card &amp;#34; @click=&amp;#34;emit(&amp;#39;poker-flip&amp;#39;, value)&amp;#34;&amp;gt; &amp;lt;Transition name=&amp;#34;card-flip&amp;#34;&amp;gt; &amp;lt;div v-if=&amp;#34;isOpen&amp;#34; class=&amp;#34;card-front&amp;#34; :class=&amp;#34;numberClass&amp;#34;&amp;gt;{{ content }}&amp;lt;/div&amp;gt; &amp;lt;div v-else class=&amp;#34;card-back&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/Transition&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; 參考Vue官方的範例， 在style添加以下後綴是-enter-active/leave-active/-enter-from/-leave-to的class，是為了讓Transition知道動畫要如何改變。
// Card.vue &amp;lt;style scoped&amp;gt; .card-flip-enter-active, .card-flip-leave-active { transition: all 0.5s ease-out; } .card-flip-enter-from, .card-flip-leave-to { opacity: 0; } {/* 略 */} 實作洗牌 實作兩個函數存於utils/poker-helper.js 洗牌的函數shuffle，洗牌採用的演算法參考看別人文章實作 Fisher-Yates 演算法，雖然洗牌用其他方法也可以，但看參考的文章說這個時間複雜度最低。 function shuffle(deck) { let length = deck.length; for (let i = 0; i &amp;lt; length; i++) { let rand_to_swap = Math.</description>
    </item>
    
    <item>
      <title>Day 03 完成卡牌自動翻面的效果，但還不完整</title>
      <link>https://kabuto412rock.github.io/posts/it-day3/</link>
      <pubDate>Tue, 12 Sep 2023 03:51:05 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day3/</guid>
      <description>原本今天預計製作發牌和卡牌自動翻面的效果，希望兩個都能有動畫效果， 但現實的能力讓我想先說說今天的開發方式
實際思考/開發的過程 卡牌翻面 想像的實作過程 沿用原本的Card.vue內的樣板，在裡面分成兩個div區塊， 一個div區塊放正面有花色數字的牌面，另一個則放一張背圖。 在Card.vue內撰寫 @click 去改變卡片的狀態 撰寫CSS的動畫去實現翻面的過程 現實開發 先調整撲克牌背面的樣板，花了些時間讓圖片不會超出卡牌寬高 background-size: cover; 上網查詢是怎麼做翻轉撲克的效果，甚至查到有人做出6個div欄位做出3D方塊，但嘗試改成只有前後的div欄位但發現景深會產生兩張卡片交疊的一點位移就放棄這個寫法 意外查到IT邦上有個純CSS挑戰撲克翻轉，所以就先照著原作的CSS翻轉寫法調整Card.vue樣板 並且添加@click 會觸發emit將點到的卡牌數字回傳至上層進行更新 // Card.vue &amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;card &amp;#34; @click=&amp;#34;emit(&amp;#39;poker-flip&amp;#39;, value)&amp;#34; :class=&amp;#34;backCardClass&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;card-front&amp;#34; :class=&amp;#34;numberClass&amp;#34;&amp;gt;{{ content }}&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;card-back&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; 因為我Vue3是採用SFC(Single-File Components)的寫法，所以定義emit的方式如下所示: // Card.vue const emit = defineEmits([&amp;#34;poker-flip&amp;#34;]); 在上層的元件要接會使用剛剛定義在defineEmits的名稱 @poker-flip // GameBoard.vue 其他都略 &amp;lt;Card v-for=&amp;#34;card in boardCards&amp;#34; key=&amp;#34;card.value&amp;#34; :value=&amp;#34;card.value&amp;#34; :isOpen=&amp;#34;card.isOpen&amp;#34; @poker-flip=&amp;#34;toggleFlip&amp;#34; /&amp;gt; 可能因為練習過ReactJS官網的的關係，知道狀態提升(Lifting State Up)的概念，所以目前所有卡牌資料依然是先放在上層的GameBoard.vue裡面，toggleFlip是我撰寫 // GameBoard.vue function toggleFlip(num) { // 找到對應的開牌狀態且翻轉 const targetIdx = boardCards.</description>
    </item>
    
    <item>
      <title>Day 02 調整css調整桌面&amp;產生52張紙牌</title>
      <link>https://kabuto412rock.github.io/posts/it-day2/</link>
      <pubDate>Mon, 11 Sep 2023 11:36:54 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day2/</guid>
      <description>動工前的準備 因為昨天標題在畫面縮放的情況下會擋住放卡牌的地方，所以早上就先看CSS相關的網站學習並且如何在Vue專案中使用。
意外發現原來App.vue檔(放置卡牌區的元件)在&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;定義的class雖然會套用到App.vue的&amp;lt;template&amp;gt;的元件中，但卻不影響App.vue內引入的GameBoard.vue&amp;lt;template&amp;gt;內使用相同class名稱的元素
修正重疊問題 關於排版的部分身為前端菜雞，就現學現賣使用將元件內部flex-wrap: wrap將包裹標題和卡牌區的main元素進行調整，如下所示:
main { display: flex; flex-wrap: wrap; } 另外並且避免標題的狐狸圖太大，直接對包裹狐狸圖的header元素進行以下的配置， 採用 overflow: hidden; 這可以避免header內的元素超出限制範圍的部分進行隱藏。
header { padding: 1rem; display: flex; align-items: center; width: fit-content; max-height: 100px; text-align: center; overflow: hidden; } 顯示卡牌在牌桌 處理完之後想到今天好像約定要怎麼將卡牌一張張顯示在畫面，但腦袋不知道為什麼想到製作卡牌花色， 所以就使用線上工具vectr製作卡牌花色分別製作成svg檔案 https://vectr.com/design/editor/1dd3ff02-4dc1-4de6-84bb-17b9446450b8
因為我昨天刻的桌子似乎不太適合顯示一堆卡牌， 馬上詢問ChatGPT『能用HTML和CSS做出撲克牌桌的樣子嗎?』
複製得到的回應(HTML和CSS)渲染在瀏覽器上看看，發現它的作法花色其實是用字元表示。 我就放棄顯示svg在div元素上的想法，還有渲染出來的牌桌顏色、卡牌的外框也都採用ChatGPT的作法。
卡牌元件 每一張卡元件都會攜帶的資訊包含一個數字，使用0~51依序去表示梅花A至黑桃K。 另外使用布林值表示當前狀態是開牌/蓋牌，如下所示:
// Card.vue const props = defineProps({ value: Number, isOpen: Boolean }); 另外也學到如果要在&amp;lt;script setup&amp;gt;中拿取屬性資料 defineProps() 需要先存在自訂義的變數，不能像 &amp;lt;template&amp;gt; 那麼自由直接取值 ，原本還想說怎麼白畫面且開發人員工具一直報Error跟我說『value is not defined』
// Card.vue const pokerValue = props.</description>
    </item>
    
    <item>
      <title>Day 01 開發遊戲前先設定目標策略</title>
      <link>https://kabuto412rock.github.io/posts/it-day1/</link>
      <pubDate>Sun, 10 Sep 2023 07:51:40 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/it-day1/</guid>
      <description>前言 最終目標是做一個個人版的紙牌接龍，中途也會嘗試做一些延伸的紙牌遊戲。
遊戲的畫面預計會使用我不熟悉的前端框架 Vue3，若有充足的時間我也會結合後端去做整合， 此次參賽也是為了督促自己在前端的技術進步。
原本是想單純參加自我挑戰組， 因為曾在2014參賽第9天就中斷，所以接下來想先在Day 1設定一些目標讓自己可以達成， 過了9年後的我可不想在同個地方掛彩。
中短期目標 目前預計想完成的目標如下:
前期目標 可以玩牌的畫面 產生紙牌 拖曳紙牌 洗牌 中期目標 紙牌動畫移動 紙牌翻轉 使用前面的技術實現心臟病遊戲 後期目標 紙牌接龍 今日目標-建好專案 建立Vue3專案並啟動成功 npm create vue@latest cd ithelp-pokergame &amp;amp;&amp;amp; npm run dev 2. 在新專案中建好git repo
git init git commit -am &amp;#39;initial&amp;#39; 在Github建好一個新的儲存庫 ithelp-pokergame 將本地的git庫跟Github的庫連上對應 git remote add origin https://github.com/kabuto412rock/ithelp-pokergame.git 決定聽從Github老大的main分支選擇，後來又比較奇怪的方式推上Github的Repo過程 # 先在本地建一個main分支 git checkout -b main # 砍了本地原始master分支 git branch -D master # 嘗試拖拉儲存庫 git pull # 設定本地main和遠端main分支對應 git branch --set-upstream-to=origin/main main # 乾脆直接把本地分支全部強推上遠端 git push -f 自己使用平板畫了一隻小狐狸，也替換到了畫面上，但畫面徹底跑版&amp;hellip; 照理來說狐狸圖應該要上下對齊才對!</description>
    </item>
    
    <item>
      <title>參加2023鐵人賽前的自我回顧</title>
      <link>https://kabuto412rock.github.io/posts/adventure-again/</link>
      <pubDate>Sun, 10 Sep 2023 02:35:25 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/adventure-again/</guid>
      <description>前言 參賽動力 工作經歷 第一份工作-軟體工程師 第二份工作-後端工程師 現在的工作? 參賽主題方向 結論 前言 因為要參加鐵人賽，所以比賽前想先鍛鍊自己的寫作能力， 撰寫為什麼要參加比賽的原因? 同時回顧自己開始工作後的經歷
參賽動力 從大學時期就知道有鐵人賽的存在，當初覺得自己技術不強、文筆也不夠好所以就不參加， 但回頭來看只是害怕失敗和變化而已
補充: 原來我曾經參加過2014鐵人賽，但沒搞清規則是連續30天在Day 9放棄了&amp;hellip; c++第十二天-字串是用陣列存取 這次參賽起因是查詢技術資料的時候，意外看到今年鐵人賽又要開始了， 或許是經過社會的摩擦後，這次我不想再逃避了!!
在提到參賽主題之前，我想先說明工作後的經歷
工作經歷 第一份工作-軟體工程師 第一份是在高雄軟體園區找到的，而在之前還婉拒了一家韌體相關C++的工作， 新鮮人的履歷大致就是畢業專題和各種寵物專案結合。
名為軟體工程師，但實際工作的項目就是開發Web版的系統， 開發環境就是網頁，你沒有看錯&amp;hellip;以現在來看就是Web版的整合開發環境(StackBlitz)， 身為一個菜鳥也是個很珍貴的經驗
可以想像成用Google Blogger一樣，寫程式就是登入工程師帳號， 如同寫文章一樣方便，但話雖如此依然需要理解HTML、CSS、JavaScript。
日常的開發就是，但畫面可以使用Bootstrap和JQuery去開發， 而公司的服務核心主要是提供客戶分析的資料，所以工作中也需要理解SQL相關的語法以及如何用平台的語法連接對應的自訂義資料來源產生圖表。
當然後端平台來源再怎麼強大，也抵不過客戶更想要靈活功能的強大，而這時往往需要寫JavaScript標準化使用者的輸入，甚至手刻一個獨一無二的時間元件也都是在工作難得的經驗。
第二份工作-後端工程師 找到這份工作前也是我在猶豫的定位是前端or後端工程師，可能因為有了第一份的經驗後， 後來在Udemy買課自學用MERN架構寫了Todo-Platform 在開發的過程中讓我確定想成為後端工程師，當然這份作品也成了我第二份工作的敲門磚，
那時還被面試官問說你前端寫的還不錯，怎麼會想投後端工程師?
我還很誠實地回應是CSS框架夠好&amp;gt;口&amp;lt;
那時使用的便是 daisyUI ，官網的範例都蠻清楚的(適合喜歡撿現成美感的朋友)
話題扯遠了!
在這間後端開發是使用NodeJS的 ExpressJS，後端工程師需要先(後)寫API文件， 中期還引入Jira進行專案管理，需要工程師根據PM開的Story 開任務票、估時數。
這份經歷讓我體驗到前後端分離的開發，系統事前的規劃、後端/前端工程師/PM之間的溝通，或許是同事比上間多很多才有的分工合作，甚至還有QA的存在，這也是我在上間較小公司難以想像的!
後端部屬的部分內部是用aaPanel(江湖名稱: 寶塔)，對外部屬就不提囉，我相信很多公司都有自己的部屬方式。 畢竟我只是想分享經驗，而非洩漏機密! 這點非常重要!
技術總是層出不窮，身為工程師也只能適應變化 by 我
現在的工作? 待業，規律生活鍛鍊身體&amp;hellip;還有學習新知?!
或許是慣性思維在後端，即使離職後我在Hahow上 Java Spring Boot課程，學習其他工程師是如何利用成熟的框架是去開發/測試API，畢竟ExpressJS的架構有點太無主見，反而需要花費更多心力在更多後端庫的結合上
參賽主題方向 在上份工作中， 身為後端工程師不太有機會去寫前端， 而是花更多時間去開發API、確認架構、資料等等， 即使撰寫網頁往往也只是利用最純粹的HTML和JavaScript做個展示
因為玩了手機App在Netflix上的接龍遊戲，想試試看我能不能用 不熟悉的語言、領域，製作Web版的我自己的接龍遊戲，若有時間也想結合後端的部分進行實作，</description>
    </item>
    
    <item>
      <title>使用Docker建立Node容器&#43;MySQL容器的範本</title>
      <link>https://kabuto412rock.github.io/posts/express-mysql-docker/</link>
      <pubDate>Tue, 06 Jun 2023 14:08:22 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/express-mysql-docker/</guid>
      <description>前言 距離上一篇文章使用Docker建立Nodejs開發環境範本 已經有1年啦! 那時竟然還擔心部落格太多文章，Github page是否會被限制
Node.js (Express.js + MySQL Server) 建置流程(快速克隆 -&amp;gt; 趕時間) 直接使用git clone語法下載範例 $ git clone https://github.com/kabuto412rock/node-demo.git --branch express-mysql --single-branch 啟動服務、關閉服務 # 進到目錄底層 $ cd node-demo # 啟動Docker服務 (node-demo) $ docker-compose up -d # 停止Docker服務 (node-demo) $ docker-compose down 相對上篇文章的差異 使用sequelize-cli進行Sequelize的設定，畢竟手寫migration、seeds太累 docker-compose.yaml多加MySQL容器、Adminer容器 express-mysqldb: image: mysql:8.0 # WARNIGN:正式環境請不要直接使用原生密碼，這只是開發偷懶用 command: --default-authentication-plugin=mysql_native_password restart: always ports: - &amp;#34;3308:3306&amp;#34; environment: # root的密碼 MYSQL_ROOT_PASSWORD: PyoA2hGpSDQordaDAbuiQIIDS # 預設建立的DB名稱 MYSQL_DATABASE: mydb # DB使用者的帳號 MYSQL_USER: dbuser # DB使用者的密碼 MYSQL_PASSWORD: youiIIDSA2hGpassword my-app資料夾可以注意到config/config.</description>
    </item>
    
    <item>
      <title>如何解決動態載入(Dynamic Import)不支援智能提示</title>
      <link>https://kabuto412rock.github.io/posts/gen-import-file/</link>
      <pubDate>Tue, 01 Nov 2022 23:28:43 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/gen-import-file/</guid>
      <description>前言 因為同事目前使用動態載入資料夾內多個程式檔案時，最後由一個特定檔案輸出，但VSCode編輯引用特定檔案的程式碼時，無法看到相對應的智能提示、引用路徑
我手上的NodeJS專案也有類似的例子，比如說多個Model檔定義在一個models資料夾， 最後統一由models/index.js做查詢檔案動態載入所有Model檔案，最後使用任一Model時只需要引用index.js
好處 只要在models新增一個新Model檔，不用特別修改index.js 需要任一Model時只需要引用index.js 壞處 失去了開發時可以享受靜態引用的VSCode提示(AutoComplete、Intellisense)
所以問題是如何保持好處且消除壞處
思考路境 動態載入不會被VSCode支援提示是因為Intellisense只支援靜態分析， 若改為添加靜態引用就失去原本的動態載入的方便。
除非添加靜態引用這件事本身是自動的&amp;hellip;
解法 使用腳本生成靜態引用，如果行得通甚至可以使用類似nodemon去watch特定資料夾內的檔案變化，達到自動生成靜態引用的功能。
範例 https://github.com/kabuto412rock/gen-static-import</description>
    </item>
    
    <item>
      <title>Linux指令-設定檔案讀寫權限 chmod</title>
      <link>https://kabuto412rock.github.io/posts/chmod-777/</link>
      <pubDate>Sun, 30 Oct 2022 04:00:14 +0000</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/chmod-777/</guid>
      <description>問題: WSL2跑Docker也可以寫原本在Ubuntu寫的hugo，又不用額外安裝homebrew 想用VSCode編輯Docker容器產生的文章後，發現我VSCode竟然沒有權限修改檔案。
解法: 辦法很簡單，修改檔案權限全開
chmod -R 777 content/ 這篇是用來測試Github action是否還有正常運作</description>
    </item>
    
    <item>
      <title>[教學] 使用Docker建立Nodejs開發環境範本</title>
      <link>https://kabuto412rock.github.io/posts/node-docker/</link>
      <pubDate>Sun, 03 Apr 2022 22:22:27 +0800</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/node-docker/</guid>
      <description>大綱
前言 為什麼要用Docker部屬 Node.js (Express.js) 建置流程Ver 1(快速克隆 -&amp;gt; 趕時間) 建置流程Ver 2 (手動 -&amp;gt; 練習過程) node-demo/app/package.json node-demo/app/src/index.js node-demo/docker-compose.yaml 資料夾結構 docker-compose建置說明 version services app (實際上可以取你自己喜歡的名稱web-app之類的) 結語 前言 最近想紀錄一下可重複使用的程式碼片段，這樣之後找就從自己的部落格找會比較方便，尤其是最近常用Docker建立部屬環境。
想看docker-compose建置Express + MYSQL環境，請走這
為什麼要用Docker部屬 雖然網路上可以找到很多理由，但我的理由是：
使用git版本控制，設定檔本身就取代環境建置說明文件 不弄髒本地環境，想刪就刪 替換依賴容易，Ex: MySQL -&amp;gt; Postgresl Docker基本上語法不複雜設定起來也很容易，尤其在建立不熟悉的環境亂試也可以， 且因為Docker有cache layer的關係，所以修改重新跑docker-compose up 也很快就可以建立。
廢話不多說，開始部屬吧&amp;hellip;
Node.js (Express.js) 建置流程Ver 1(快速克隆 -&amp;gt; 趕時間) 直接使用git clone語法下載範例 $ git clone https://github.com/kabuto412rock/node-demo.git --branch express_template --single-branch 啟動服務、關閉服務 # 進到目錄底層 $ cd node-demo # 啟動Docker服務 (node-demo) $ docker-compose up -d # 停止Docker服務 (node-demo) $ docker-compose down 檢查實際結果 http://localhost/ 建置流程Ver 2 (手動 -&amp;gt; 練習過程) 建立相關的檔案＆安裝Express（主要是為了產生package.</description>
    </item>
    
    <item>
      <title>[Debug過程] 學Hugo並發布到Github page</title>
      <link>https://kabuto412rock.github.io/posts/my-first-post/</link>
      <pubDate>Sat, 27 Nov 2021 23:03:49 +0800</pubDate>
      
      <guid>https://kabuto412rock.github.io/posts/my-first-post/</guid>
      <description>前言 如果你正在尋找一篇Hugo建立GithubPag的教學文，請你繼續搜尋其他文章， 因為這是我第一次使用Hugo跌跌撞撞的除錯紀錄， 而大部分問題都是我自己不照教學走導致需要Debug的文章， 但如果想知道怎麼出錯解錯就繼續看下去，但不建議跟著做下去。
Bug1 前幾次hugo server -D啟動正常，後來卻出錯? 本來想說安裝extended版本比較好，所以重新用snap安裝穩定版， 結果啟動伺服器得到以下結果：
hugo v0.89.4 linux/amd64 BuildDate=2021-11-17T14:49:26Z Error: Error building site: TOCSS: failed to transform &amp;#34;ananke/css/main.css&amp;#34; (text/css). Check your Hugo installation; you need the extended version to build SCSS/SASS.: this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information Built in 14 ms 我是在Ubuntu的環境下用 snap install hugo安裝Hugo， 而錯誤的原因是用extended版產生部落格，後面又重新切換Hugo穩定版， 但原本的部落格資料需要SCSS/SASS的支援所以才會出現這樣的錯誤。
解法 因為懶得重新生成檔案，乾脆就用SCSS版本的Hugo：
snap remove hugo snap install hugo --channel=extended 或是使用官方提供的方法切換版本：</description>
    </item>
    
  </channel>
</rss>
